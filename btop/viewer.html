<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>btop</title>
    <style>
        @font-face {
            font-family: 'JetBrainsMono NF';
            src: url('/fonts/JetBrainsMonoNerdFontMono-Regular.ttf') format('truetype'),
                 local('JetBrainsMono Nerd Font Mono'),
                 local('JetBrainsMono NF');
            font-weight: normal;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { 
            background: #000; 
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        #container {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        #terminal {
            display: grid;
            grid-template-columns: repeat(132, 6px);
            grid-template-rows: repeat(43, 12px);
            font-family: 'JetBrainsMono NF', monospace;
            font-size: 10px;
            line-height: 1;
            background: #000;
            transform-origin: center center;
            position: relative;
        }
        #terminal span {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 6px;
            height: 12px;
            overflow: hidden;
        }
        
        /* Simple phosphor fade - terminal fades in from black */
        #terminal {
            opacity: 0;
            transition: opacity 0.4s ease-in;
        }
        #terminal.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="terminal"></div>
    </div>
    
    <script>
        const COLS = 132;
        const ROWS = 43;
        const TOTAL_CELLS = COLS * ROWS;
        const container = document.getElementById('container');
        const terminal = document.getElementById('terminal');
        
        // Connection state
        let eventSource = null;
        let reconnectTimeout = null;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_DELAY = 30000;
        
        // Cell state array
        let cells = new Array(TOTAL_CELLS);
        for (let i = 0; i < TOTAL_CELLS; i++) {
            cells[i] = [' ', null, null, 0];
        }
        
        // DOM span elements
        let spans = [];
        let hasReceivedFirstFrame = false;
        
        function initGrid() {
            const fragment = document.createDocumentFragment();
            for (let i = 0; i < TOTAL_CELLS; i++) {
                const span = document.createElement('span');
                span.textContent = '\u00A0';
                fragment.appendChild(span);
                spans.push(span);
            }
            terminal.appendChild(fragment);
        }
        
        function show() {
            terminal.classList.add('visible');
        }
        
        function hide() {
            terminal.classList.remove('visible');
        }
        
        function updateCell(index, char, fg, bg, bold) {
            const span = spans[index];
            if (!span) return;
            
            span.textContent = char === ' ' ? '\u00A0' : char;
            span.style.color = fg ? '#' + fg : '';
            span.style.background = bg ? '#' + bg : '';
            span.style.fontWeight = bold ? 'bold' : '';
        }
        
        function handleMessage(data) {
            // Render data first
            if (data.t === 'f') {
                cells = data.c;
                for (let i = 0; i < TOTAL_CELLS; i++) {
                    const [char, fg, bg, bold] = cells[i];
                    updateCell(i, char, fg, bg, bold);
                }
            } else if (data.t === 'd') {
                for (const change of data.d) {
                    const [index, char, fg, bg, bold] = change;
                    cells[index] = [char, fg, bg, bold];
                    updateCell(index, char, fg, bg, bold);
                }
            }
            
            // On first frame, fade in
            if (!hasReceivedFirstFrame) {
                hasReceivedFirstFrame = true;
                show();
            }
        }
        
        function resize() {
            const cellW = 6;
            const cellH = 12;
            const termW = COLS * cellW;
            const termH = ROWS * cellH;
            
            terminal.style.width = termW + 'px';
            terminal.style.height = termH + 'px';
            terminal.style.fontSize = (cellH * 0.85) + 'px';
            
            const scaleX = container.clientWidth / termW;
            const scaleY = container.clientHeight / termH;
            const scale = Math.min(scaleX, scaleY);
            
            terminal.style.transform = `scale(${scale})`;
            
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'btop-dimensions',
                    aspectRatio: 1.534
                }, '*');
            }
        }
        
        function getStreamUrl() {
            const path = window.location.pathname;
            if (path.includes('/api/btop')) return '/api/btop/stream';
            return '/stream';
        }
        
        function connect() {
            if (eventSource) {
                eventSource.close();
            }
            
            eventSource = new EventSource(getStreamUrl());
            
            eventSource.onopen = () => {
                reconnectAttempts = 0;
            };
            
            eventSource.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    handleMessage(data);
                } catch (e) {
                    console.error('[btop] Parse error:', e);
                }
            };
            
            eventSource.onerror = () => {
                eventSource.close();
                eventSource = null;
                
                hide();
                hasReceivedFirstFrame = false;
                
                if (document.visibilityState !== 'visible') {
                    return;
                }
                
                const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), MAX_RECONNECT_DELAY);
                reconnectAttempts++;
                reconnectTimeout = setTimeout(connect, delay);
            };
        }
        
        function disconnect() {
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }
        }
        
        function handleVisibilityChange() {
            if (document.visibilityState === 'visible') {
                if (!eventSource || eventSource.readyState !== EventSource.OPEN) {
                    reconnectAttempts = 0;
                    hide();
                    hasReceivedFirstFrame = false;
                    connect();
                }
            } else {
                disconnect();
            }
        }
        
        // Initialize
        initGrid();
        resize();
        
        window.addEventListener('resize', resize);
        document.addEventListener('visibilitychange', handleVisibilityChange);
        
        connect();
    </script>
</body>
</html>